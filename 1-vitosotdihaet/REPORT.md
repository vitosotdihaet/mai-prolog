# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Клименко В. М., М8О-203Б-22, 10 вариант

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
<!-- Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры данных в традиционных языках похожи списки в Прологе? -->

Списки в Прологе представляются такой структурой данных как связный список, в то время как в императивных языках программирования списки обычно хранятся как подряд-идущие в памяти ссылки на объекты. В императивных языках доступ в элементам производится по индексу, а в Прологе зависит от выбора программиста (например nth0, при помощи которого можно искать элементы как по индексу, так и по значению). В Прологе списки неизменяемы.


## Задание 1.1: Предикат обработки списка

`delete_at(Index, List, Result)` - удаляет из списка `List` элемент под номером `Index`. Если индекс меньше 1 или больше чем длина списка, возвращает `false`.

Примеры использования:
```prolog
?- delete_at(4, [a, b, c, a], R).
R = [a, b, c].

?- delete_at(1, [a, b, c, a], R).
R = [b, c, a].

?- delete_at(-1, [a, b, c, a], R).
false.

?- delete_at(5, [a, b, c, a], R).
false.
```

Реализация:
```prolog
delete_at(1, [_ | List], List) :- !.
delete_at(Index, [H | List], [H | Result]) :-
    length([H | List], Length),
    Index =< Length, Index > 0,
    NewIndex is Index - 1,
    delete_at(NewIndex, List, Result).
```

Реализация рекурсивная. Первый факт рассматривает вариант, где удаляется первый элемент. Дальше уже идет рекурсивная реализация: сначала проверяется, входит ли `Index` в рамки дозволенного. Дальше индекс уменьшается на единицу, после чего список без первого элемента и индекс передаются в этот же предикат. Когда `Index` станет равным одному, мы попадаем в первый рассмотренный случай.

## Задание 1.2: Предикат обработки числового списка

`sum(List1, List2, Result)` - складывает списки `List1` и `List2` в `Result`.

Примеры использования:
```prolog
?- sum([1, 2], [3, 4], R).
R = [4, 6].

?- sum([1, 2], [3], R).
R = [4, 2].

?- sum([1, 2, 5, 6], [3], R).
R = [4, 2, 5, 6].

?- sum([1, -2, 5, 6], [1, 1, -1, 1, 1], R).
R = [2, -1, 4, 7, 1].

?- sum([], [1], R).
R = [1].
```

Реализация:
```prolog
sum([], List, List) :- !.
sum(List, [], List) :- !.
sum([N1 | T1], [N2 | T2], [Sum | T]) :-
    Sum is N1 + N2,
    sum(T1, T2, T).
```

Реализация рекурсивная. Первые два факта рассматривают варианты сложения с пустым списком. Дальше идет рекурсивная реализация: каждый шаг мы складываем первые элементы, после чего предаем оставшиеся (несложенные) части списков в этот предикат. Когда один из списков станет пустым, мы попадаем в один из первых рассмотренных случаев.

## Задание 2: Реляционное представление данных
<!-- Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным. -->

### Реляционное представление данных
Основное преимущество реляционного представления - упорядоченность и связанность между собой данных.

Реляционная база данных требует большого объема физической памяти.

Преимущество именно третьего представление заключается в том, что все данные о студенте находятся в одном предикате. 

Из недостатков - необходимость обработки лишних данных в некоторых предикатах, излишний повтор поиска.

### Использованные предикаты
```prolog
group_students(GroupNumber, List) % собирается List из имен студентов найденных findall'ом по номеру группы
group_grades_list(GroupNumber, List) % собирается общий список оценок List из списков оценок по каждому отдельному предмету, найденных через findall по номеру группы
subject_not_passed_students(List) % собираем все имена студентов в List из findall'а по оценке предмета subject
```

## Выводы

<!-- Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную. -->

В ходе выполнения данной лабораторной работы, я познакомился с декларативным программированием. На примере увидел, что в логическом программировании важнее понимать, что из себя представляет ответ на поставленную задачу, чем продумывать каждый ход решения, как это принято в императивном программировании.

По окончанию выполнения лабораторной работы, я убедился, что с таким декларативным языком программирования как Пролог можно легко работать с базами данных.
